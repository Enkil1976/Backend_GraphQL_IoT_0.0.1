const { execSync } = require('child_process');
const fs = require('fs').promises;
const path = require('path');
const crypto = require('crypto');
const auditLogService = require('./auditLogService');

/**
 * Automated Vulnerability Detection Service
 * Scans for security vulnerabilities and misconfigurations
 */
class VulnerabilityScanner {
  constructor() {
    this.scanIntervalMs = 24 * 60 * 60 * 1000; // 24 hours
    this.isScanning = false;
    this.lastScan = null;
    this.vulnerabilities = [];
    this.scanHistory = [];

    // Security patterns to detect
    this.securityPatterns = {
      secrets: [
        /password\s*=\s*['"][^'"]{8,}['"]/gi,
        /api[_-]?key\s*=\s*['"][^'"]{16,}['"]/gi,
        /secret\s*=\s*['"][^'"]{16,}['"]/gi,
        /token\s*=\s*['"][^'"]{20,}['"]/gi,
        /AKIA[0-9A-Z]{16}/g, // AWS Access Key
        /ghp_[a-zA-Z0-9]{36}/g, // GitHub Personal Access Token
        /sk_live_[a-zA-Z0-9]{24}/g // Stripe Live Secret Key
      ],
      sqlInjection: [
        /\$\{[^}]*\}/g, // Template literals in SQL
        /\+\s*['"]\s*or\s*['"]/gi,
        /union\s+select/gi,
        /drop\s+table/gi
      ],
      xss: [
        /innerHTML\s*=\s*[^;]+(?:req\.|params\.|query\.)/gi,
        /document\.write\s*\([^)]*(?:req\.|params\.|query\.)/gi,
        /dangerouslySetInnerHTML/gi
      ],
      pathTraversal: [
        /\.\.\//g,
        /\\.\\.\\\\/g,
        /path\.join\([^)]*\.\./gi
      ],
      unsafeEval: [
        /eval\s*\(/gi,
        /Function\s*\(/gi,
        /setTimeout\s*\(\s*['"][^'"]*['"]/gi,
        /setInterval\s*\(\s*['"][^'"]*['"]/gi
      ]
    };

    // File patterns that should be secured
    this.sensitiveFiles = [
      '.env',
      'config.json',
      'database.json',
      'secrets.json',
      '*.pem',
      '*.key',
      '*_rsa',
      '*.p12',
      '*.pfx'
    ];

    // Start automated scanning if enabled
    if (process.env.AUTO_VULNERABILITY_SCAN === 'true') {
      this.startAutomatedScanning();
    }
  }

  /**
   * Start automated vulnerability scanning
   */
  startAutomatedScanning() {
    console.log('üîç Starting automated vulnerability scanning...');

    // Initial scan after startup delay
    setTimeout(() => {
      this.performFullScan();
    }, 5 * 60 * 1000); // 5 minutes after startup

    // Periodic scans
    setInterval(() => {
      this.performFullScan();
    }, this.scanIntervalMs);
  }

  /**
   * Perform comprehensive security scan
   */
  async performFullScan() {
    if (this.isScanning) {
      console.log('‚è≥ Vulnerability scan already in progress');
      return;
    }

    this.isScanning = true;
    const scanId = crypto.randomUUID();
    const startTime = Date.now();

    try {
      console.log(`üîç Starting vulnerability scan ${scanId}...`);

      const results = {
        scanId,
        timestamp: new Date().toISOString(),
        vulnerabilities: [],
        warnings: [],
        info: []
      };

      // Run all scan modules
      await Promise.all([
        this.scanDependencies(results),
        this.scanSourceCode(results),
        this.scanConfiguration(results),
        this.scanFilePermissions(results),
        this.scanEnvironment(results),
        this.scanNetworkSecurity(results)
      ]);

      const duration = Date.now() - startTime;
      results.duration = duration;
      results.summary = this.generateScanSummary(results);

      // Store scan results
      this.lastScan = results;
      this.scanHistory.push({
        scanId,
        timestamp: results.timestamp,
        vulnerabilityCount: results.vulnerabilities.length,
        warningCount: results.warnings.length,
        duration
      });

      // Keep only last 10 scan histories
      if (this.scanHistory.length > 10) {
        this.scanHistory = this.scanHistory.slice(-10);
      }

      // Log critical vulnerabilities
      const criticalVulns = results.vulnerabilities.filter(v => v.severity === 'critical');
      if (criticalVulns.length > 0) {
        await auditLogService.logSecurityViolation(
          'CRITICAL_VULNERABILITIES_DETECTED',
          {
            scan_id: scanId,
            critical_count: criticalVulns.length,
            vulnerabilities: criticalVulns.map(v => ({
              type: v.type,
              description: v.description,
              file: v.file
            }))
          },
          null,
          null
        );
      }

      console.log(`‚úÖ Vulnerability scan completed in ${duration}ms`);
      console.log(`üìä Found: ${results.vulnerabilities.length} vulnerabilities, ${results.warnings.length} warnings`);

    } catch (error) {
      console.error('‚ùå Vulnerability scan failed:', error);

      await auditLogService.logSystemEvent(
        'VULNERABILITY_SCAN_FAILED',
        { error: error.message, scan_id: scanId },
        null,
        null
      );
    } finally {
      this.isScanning = false;
    }
  }

  /**
   * Scan npm dependencies for vulnerabilities
   */
  async scanDependencies(results) {
    try {
      console.log('üîç Scanning dependencies...');

      // Run npm audit
      const auditOutput = execSync('npm audit --json', {
        encoding: 'utf8',
        cwd: process.cwd()
      });

      const audit = JSON.parse(auditOutput);

      if (audit.vulnerabilities) {
        Object.entries(audit.vulnerabilities).forEach(([packageName, vulnerability]) => {
          const severity = vulnerability.severity;
          const advisory = vulnerability.via?.[0];

          if (advisory && typeof advisory === 'object') {
            results.vulnerabilities.push({
              type: 'dependency',
              severity: this.mapNpmSeverity(severity),
              package: packageName,
              description: advisory.title || `Vulnerability in ${packageName}`,
              cve: advisory.cve || null,
              url: advisory.url || null,
              recommendation: `Update ${packageName} to fix vulnerability`
            });
          }
        });
      }

    } catch (error) {
      results.warnings.push({
        type: 'scan_error',
        description: 'Failed to scan dependencies',
        error: error.message
      });
    }
  }

  /**
   * Scan source code for security patterns
   */
  async scanSourceCode(results) {
    try {
      console.log('üîç Scanning source code...');

      const sourceFiles = await this.getSourceFiles();

      for (const file of sourceFiles) {
        const content = await fs.readFile(file, 'utf8');

        // Check for secrets in code
        this.checkForSecrets(file, content, results);

        // Check for SQL injection patterns
        this.checkForSQLInjection(file, content, results);

        // Check for XSS vulnerabilities
        this.checkForXSS(file, content, results);

        // Check for path traversal
        this.checkForPathTraversal(file, content, results);

        // Check for unsafe eval usage
        this.checkForUnsafeEval(file, content, results);
      }

    } catch (error) {
      results.warnings.push({
        type: 'scan_error',
        description: 'Failed to scan source code',
        error: error.message
      });
    }
  }

  /**
   * Scan configuration files for security issues
   */
  async scanConfiguration(results) {
    try {
      console.log('üîç Scanning configuration...');

      // Check .env file security
      await this.checkEnvFile(results);

      // Check package.json security
      await this.checkPackageJson(results);

      // Check for exposed sensitive files
      await this.checkSensitiveFiles(results);

    } catch (error) {
      results.warnings.push({
        type: 'scan_error',
        description: 'Failed to scan configuration',
        error: error.message
      });
    }
  }

  /**
   * Check file permissions for security issues
   */
  async scanFilePermissions(results) {
    try {
      console.log('üîç Scanning file permissions...');

      const sensitiveFiles = ['.env', 'config.json', 'package.json'];

      for (const file of sensitiveFiles) {
        try {
          const stats = await fs.stat(file);
          const mode = (stats.mode & parseInt('777', 8)).toString(8);

          // Check for overly permissive files
          if (mode.endsWith('77') || mode.endsWith('66')) {
            results.vulnerabilities.push({
              type: 'file_permissions',
              severity: 'medium',
              file,
              description: `File ${file} has overly permissive permissions (${mode})`,
              recommendation: `Change permissions to 600: chmod 600 ${file}`
            });
          }
        } catch (error) {
          // File doesn't exist, skip
        }
      }

    } catch (error) {
      results.warnings.push({
        type: 'scan_error',
        description: 'Failed to scan file permissions',
        error: error.message
      });
    }
  }

  /**
   * Scan environment configuration
   */
  async scanEnvironment(results) {
    try {
      console.log('üîç Scanning environment...');

      // Check for required security environment variables
      const requiredSecurityVars = [
        'JWT_SECRET',
        'ENCRYPTION_MASTER_KEY',
        'DATABASE_ENCRYPTION_KEY'
      ];

      for (const varName of requiredSecurityVars) {
        if (!process.env[varName]) {
          results.vulnerabilities.push({
            type: 'missing_env_var',
            severity: 'high',
            description: `Missing required security environment variable: ${varName}`,
            recommendation: `Set ${varName} environment variable with a strong random value`
          });
        }
      }

      // Check for weak secrets
      if (process.env.JWT_SECRET && process.env.JWT_SECRET.length < 32) {
        results.vulnerabilities.push({
          type: 'weak_secret',
          severity: 'high',
          description: 'JWT_SECRET is too short (less than 32 characters)',
          recommendation: 'Use a stronger JWT_SECRET with at least 32 characters'
        });
      }

      // Check for development settings in production
      if (process.env.NODE_ENV === 'production') {
        if (process.env.DEBUG === 'true') {
          results.vulnerabilities.push({
            type: 'debug_enabled',
            severity: 'medium',
            description: 'Debug mode is enabled in production',
            recommendation: 'Disable debug mode in production by removing DEBUG=true'
          });
        }
      }

    } catch (error) {
      results.warnings.push({
        type: 'scan_error',
        description: 'Failed to scan environment',
        error: error.message
      });
    }
  }

  /**
   * Scan network security configuration
   */
  async scanNetworkSecurity(results) {
    try {
      console.log('üîç Scanning network security...');

      // Check if HTTPS is enforced
      if (!process.env.FORCE_HTTPS && process.env.NODE_ENV === 'production') {
        results.warnings.push({
          type: 'https_not_enforced',
          description: 'HTTPS is not enforced in production',
          recommendation: 'Set FORCE_HTTPS=true in production environment'
        });
      }

      // Check CORS configuration
      if (process.env.CORS_ORIGINS === '*') {
        results.vulnerabilities.push({
          type: 'permissive_cors',
          severity: 'medium',
          description: 'CORS is configured to allow all origins (*)',
          recommendation: 'Restrict CORS_ORIGINS to specific trusted domains'
        });
      }

    } catch (error) {
      results.warnings.push({
        type: 'scan_error',
        description: 'Failed to scan network security',
        error: error.message
      });
    }
  }

  /**
   * Get list of source files to scan
   */
  async getSourceFiles() {
    const extensions = ['.js', '.ts', '.jsx', '.tsx'];
    const sourceFiles = [];

    const scanDirectory = async(dir) => {
      try {
        const entries = await fs.readdir(dir, { withFileTypes: true });

        for (const entry of entries) {
          const fullPath = path.join(dir, entry.name);

          if (entry.isDirectory() && !entry.name.startsWith('.') && entry.name !== 'node_modules') {
            await scanDirectory(fullPath);
          } else if (entry.isFile() && extensions.some(ext => entry.name.endsWith(ext))) {
            sourceFiles.push(fullPath);
          }
        }
      } catch (error) {
        // Skip inaccessible directories
      }
    };

    await scanDirectory('./src');
    return sourceFiles;
  }

  /**
   * Check for secrets in source code
   */
  checkForSecrets(file, content, results) {
    this.securityPatterns.secrets.forEach(pattern => {
      const matches = content.match(pattern);
      if (matches) {
        matches.forEach(match => {
          results.vulnerabilities.push({
            type: 'exposed_secret',
            severity: 'critical',
            file,
            description: `Potential secret found in source code: ${match.substring(0, 50)}...`,
            recommendation: 'Move secrets to environment variables or secure configuration'
          });
        });
      }
    });
  }

  /**
   * Check for SQL injection vulnerabilities
   */
  checkForSQLInjection(file, content, results) {
    this.securityPatterns.sqlInjection.forEach(pattern => {
      const matches = content.match(pattern);
      if (matches) {
        results.vulnerabilities.push({
          type: 'sql_injection',
          severity: 'high',
          file,
          description: 'Potential SQL injection vulnerability detected',
          recommendation: 'Use parameterized queries or prepared statements'
        });
      }
    });
  }

  /**
   * Check for XSS vulnerabilities
   */
  checkForXSS(file, content, results) {
    this.securityPatterns.xss.forEach(pattern => {
      const matches = content.match(pattern);
      if (matches) {
        results.vulnerabilities.push({
          type: 'xss',
          severity: 'high',
          file,
          description: 'Potential XSS vulnerability detected',
          recommendation: 'Sanitize user input before rendering'
        });
      }
    });
  }

  /**
   * Check for path traversal vulnerabilities
   */
  checkForPathTraversal(file, content, results) {
    this.securityPatterns.pathTraversal.forEach(pattern => {
      const matches = content.match(pattern);
      if (matches) {
        results.vulnerabilities.push({
          type: 'path_traversal',
          severity: 'high',
          file,
          description: 'Potential path traversal vulnerability detected',
          recommendation: 'Validate and sanitize file paths'
        });
      }
    });
  }

  /**
   * Check for unsafe eval usage
   */
  checkForUnsafeEval(file, content, results) {
    this.securityPatterns.unsafeEval.forEach(pattern => {
      const matches = content.match(pattern);
      if (matches) {
        results.vulnerabilities.push({
          type: 'unsafe_eval',
          severity: 'high',
          file,
          description: 'Unsafe eval or Function constructor usage detected',
          recommendation: 'Avoid using eval() or Function constructor with user input'
        });
      }
    });
  }

  /**
   * Check .env file for security issues
   */
  async checkEnvFile(results) {
    try {
      const envContent = await fs.readFile('.env', 'utf8');

      // Check for weak values
      if (envContent.includes('password=123456') ||
          envContent.includes('secret=secret') ||
          envContent.includes('key=test')) {
        results.vulnerabilities.push({
          type: 'weak_credentials',
          severity: 'critical',
          file: '.env',
          description: 'Weak default credentials found in .env file',
          recommendation: 'Use strong, randomly generated credentials'
        });
      }

    } catch (error) {
      // .env file doesn't exist or not readable
    }
  }

  /**
   * Check package.json for security issues
   */
  async checkPackageJson(results) {
    try {
      const packageContent = await fs.readFile('package.json', 'utf8');
      const packageJson = JSON.parse(packageContent);

      // Check for scripts that might be dangerous
      if (packageJson.scripts) {
        Object.entries(packageJson.scripts).forEach(([scriptName, scriptCommand]) => {
          if (scriptCommand.includes('rm -rf') ||
              scriptCommand.includes('sudo') ||
              scriptCommand.includes('curl | sh')) {
            results.warnings.push({
              type: 'dangerous_script',
              description: `Potentially dangerous script found: ${scriptName}`,
              recommendation: 'Review script for security implications'
            });
          }
        });
      }

    } catch (error) {
      // package.json not readable
    }
  }

  /**
   * Check for exposed sensitive files
   */
  async checkSensitiveFiles(results) {
    for (const pattern of this.sensitiveFiles) {
      try {
        // Simple check for exact filename
        if (!pattern.includes('*')) {
          await fs.access(pattern);
          results.warnings.push({
            type: 'sensitive_file_exposed',
            description: `Sensitive file found: ${pattern}`,
            recommendation: `Ensure ${pattern} is not committed to version control`
          });
        }
      } catch (error) {
        // File doesn't exist, which is good
      }
    }
  }

  /**
   * Map npm audit severity to our severity levels
   */
  mapNpmSeverity(npmSeverity) {
    const mapping = {
      'critical': 'critical',
      'high': 'high',
      'moderate': 'medium',
      'low': 'low',
      'info': 'info'
    };

    return mapping[npmSeverity] || 'medium';
  }

  /**
   * Generate scan summary
   */
  generateScanSummary(results) {
    const severityCounts = results.vulnerabilities.reduce((acc, vuln) => {
      acc[vuln.severity] = (acc[vuln.severity] || 0) + 1;
      return acc;
    }, {});

    return {
      total_vulnerabilities: results.vulnerabilities.length,
      total_warnings: results.warnings.length,
      severity_breakdown: severityCounts,
      risk_score: this.calculateRiskScore(severityCounts)
    };
  }

  /**
   * Calculate overall risk score
   */
  calculateRiskScore(severityCounts) {
    const weights = {
      critical: 10,
      high: 7,
      medium: 4,
      low: 2,
      info: 1
    };

    let score = 0;
    Object.entries(severityCounts).forEach(([severity, count]) => {
      score += (weights[severity] || 0) * count;
    });

    if (score === 0) return 'low';
    if (score <= 10) return 'medium';
    if (score <= 30) return 'high';
    return 'critical';
  }

  /**
   * Get last scan results
   */
  getLastScanResults() {
    return this.lastScan;
  }

  /**
   * Get scan history
   */
  getScanHistory() {
    return this.scanHistory;
  }

  /**
   * Get scanner status
   */
  getStatus() {
    return {
      is_scanning: this.isScanning,
      last_scan: this.lastScan?.timestamp || null,
      scan_interval_hours: this.scanIntervalMs / (60 * 60 * 1000),
      auto_scan_enabled: process.env.AUTO_VULNERABILITY_SCAN === 'true',
      total_scans: this.scanHistory.length
    };
  }
}

module.exports = new VulnerabilityScanner();
